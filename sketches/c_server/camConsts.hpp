/*
# 
# Copyright (C) 2016~2021 The Gimli Project
# This file is part of rpiCap <https://github.com/bit-meddler/rpiCap>.
#
# rpiCap is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# rpiCap is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with rpiCap.  If not, see <http://www.gnu.org/licenses/>.
#
*/
#pragma once
#include <string>

namespace CamConsts {
// Consts
// Socket and comms
const std::string SERVER_IP      = "192.168.0.20" ;
const int         UDP_PORT_TX    = 1234 ; // Server's RX
const int         UDP_PORT_RX    = 1235 ; // Server's TX
const int         SOCKET_TIMEOUT =   10 ; // Select Timeout (secs)
const int         RECV_BUFF_SZ   =  256 ; // should only receve 1, 3, 5, or 7 Byte messages

// Command & Control
const char CMD_START   = 0x6E ; // 'n'
const char CMD_STOP    = 0x20 ; // ' '
const char CMD_SINGLE  = 0x70 ; // 'p'
const char CMD_STREAM  = 0x73 ; // 's'
const char REQ_REGSLO  = 0x72 ; // 'r'
const char REQ_REGSHI  = 0x52 ; // 'R'
const char REQ_VERSION = 0x3F ; // '?'
const char REQ_HELLO   = 0x68 ; // 'h'
const char SET_BYTE    = 0x2A ; // '*'
const char SET_SHORT   = 0x7E ; // '~'
const char SET_WORD    = 0x21 ; // '!'

// Packetization
const char PACKET_ROIDS = 0x00 ;
const char PACKET_IMAGE = 0x0A ;
const char PACKET_REGLO = 0x0C ;
const char PACKET_REGHI = 0x0E ;
const char PACKET_TEXT  = 0x10 ;
const char PACKET_VERS  = 0x11 ;

// Centroid Pack format
const char ROIDS_8BYTE  = 0x00 ;
const char ROIDS_10BYTE = 0x04 ;

// Queue Priority
const int  PRI_IMMEDIATE =  1 ;
const int  PRI_NORMAL    = 10 ;
const int  PRI_IMAGES    = 50 ;

// Type Defs

// Prioritized data packet (remember to delete the data!)
struct QPacket {
    int      priority ; // priority
    size_t   size ;     // size of the buffer
    uint8_t* data ;     // pointer to a dynamic buffer (The datagram)
 
    QPacket( const int priority, const size_t size, uint8_t* datagram ) :
             priority(priority), size(size), data(datagram) {
    }

    friend bool operator< (QPacket const& lhs, QPacket const& rhs) {
        // note: reversing for "lowest is best" ordering
        return lhs.priority > rhs.priority ;
    }
 
    friend std::ostream& operator<< (std::ostream& os, QPacket const& p) {
        return os << "{" << p.priority << " [" << p.size << "]} " ;
    }
} ;

// Camera Registers - Generated by "$REPO/piCap/sketches/genRegsStruct.py"
struct CamRegs {
    union {
        uint8_t       reg[1024] ;          // index access
        struct {                           // variable access
            /******** P R I V A T E  R E G S ****************************/
            uint8_t   _roid_stream ;       // PRIVATE should we be streaming 'roids?
            uint8_t   _send_one_img ;      // send one image
            uint8_t   _img_stream ;        // stream images
            uint8_t   __unknown_0[197] ;   // Here be Dragons
            /******** K N O W N   R E G S *******************************/
            uint8_t   fps ;                // reg 200
            uint8_t   __unknown_1[3] ;     // Unknown
            uint8_t   strobe ;             // reg 204
            uint8_t   __unknown_2 ;        // Unknown
            uint8_t   shutter ;            // reg 206
            uint8_t   __unknown_3[7] ;     // Unknown
             int16_t  impactrefx ;         // reg 214 signed
             int16_t  impactrefy ;         // reg 216 signed
             int16_t  impactrefz ;         // reg 218 signed
            uint8_t   __unknown_4[6] ;     // Unknown
            uint8_t   arpdelay ;           // reg 226
            uint8_t   __unknown_5[3] ;     // Unknown
             int16_t  impactvalx ;         // reg 230 signed
             int16_t  impactvaly ;         // reg 232 signed
             int16_t  impactvalz ;         // reg 234 signed
            uint8_t   impactflags ;        // reg 236
            uint8_t   __unknown_6[12] ;    // Unknown
            uint8_t   impactlimit ;        // reg 249
            uint8_t   __unknown_7 ;        // Unknown
            uint8_t   mtu ;                // reg 251
            uint8_t   iscale ;             // reg 252
            uint8_t   idelay ;             // reg 253
            uint8_t   numdets ;            // reg 254
            uint8_t   threshold ;          // reg 255
            uint8_t   __unknown_8[44] ;    // Here be Dragons
            uint16_t  maskzone01x ;        // reg 300
            uint16_t  maskzone01y ;        // reg 302
            uint16_t  maskzone01m ;        // reg 304
            uint16_t  maskzone01n ;        // reg 306
            uint16_t  maskzone02x ;        // reg 308
            uint16_t  maskzone02y ;        // reg 310
            uint16_t  maskzone02m ;        // reg 312
            uint16_t  maskzone02n ;        // reg 314
            uint16_t  maskzone03x ;        // reg 316
            uint16_t  maskzone03y ;        // reg 318
            uint16_t  maskzone03m ;        // reg 320
            uint16_t  maskzone03n ;        // reg 322
            uint16_t  maskzone04x ;        // reg 324
            uint16_t  maskzone04y ;        // reg 326
            uint16_t  maskzone04m ;        // reg 328
            uint16_t  maskzone04n ;        // reg 330
            uint16_t  maskzone05x ;        // reg 332
            uint16_t  maskzone05y ;        // reg 334
            uint16_t  maskzone05m ;        // reg 336
            uint16_t  maskzone05n ;        // reg 338
            uint16_t  maskzone06x ;        // reg 340
            uint16_t  maskzone06y ;        // reg 342
            uint16_t  maskzone06m ;        // reg 344
            uint16_t  maskzone06n ;        // reg 346
            uint16_t  maskzone07x ;        // reg 348
            uint16_t  maskzone07y ;        // reg 350
            uint16_t  maskzone07m ;        // reg 352
            uint16_t  maskzone07n ;        // reg 354
            uint16_t  maskzone08x ;        // reg 356
            uint16_t  maskzone08y ;        // reg 358
            uint16_t  maskzone08m ;        // reg 360
            uint16_t  maskzone08n ;        // reg 362
            uint16_t  maskzone09x ;        // reg 364
            uint16_t  maskzone09y ;        // reg 366
            uint16_t  maskzone09m ;        // reg 368
            uint16_t  maskzone09n ;        // reg 370
            uint16_t  maskzone10x ;        // reg 372
            uint16_t  maskzone10y ;        // reg 374
            uint16_t  maskzone10m ;        // reg 376
            uint16_t  maskzone10n ;        // reg 378
            uint16_t  maskzone11x ;        // reg 380
            uint16_t  maskzone11y ;        // reg 382
            uint16_t  maskzone11m ;        // reg 384
            uint16_t  maskzone11n ;        // reg 386
            uint16_t  maskzone12x ;        // reg 388
            uint16_t  maskzone12y ;        // reg 390
            uint16_t  maskzone12m ;        // reg 392
            uint16_t  maskzone12n ;        // reg 394
            uint16_t  maskzone13x ;        // reg 396
            uint16_t  maskzone13y ;        // reg 398
            uint16_t  maskzone13m ;        // reg 400
            uint16_t  maskzone13n ;        // reg 402
            uint16_t  maskzone14x ;        // reg 404
            uint16_t  maskzone14y ;        // reg 406
            uint16_t  maskzone14m ;        // reg 408
            uint16_t  maskzone14n ;        // reg 410
            uint16_t  maskzone15x ;        // reg 412
            uint16_t  maskzone15y ;        // reg 414
            uint16_t  maskzone15m ;        // reg 416
            uint16_t  maskzone15n ;        // reg 418
            uint16_t  maskzone16x ;        // reg 420
            uint16_t  maskzone16y ;        // reg 422
            uint16_t  maskzone16m ;        // reg 424
            uint16_t  maskzone16n ;        // reg 426
            uint8_t   __unknown_9[595] ;   // Here be Dragons
        } ; // var struct
    } ; // union
} ; // camRegs

// Packetization helper
struct PacketData {
    uint32_t roll_cnt {0} ; // rolling counter
    uint32_t packet_cnt {0} ; // packet counter

    void inc( void ) {
        packet_cnt++ ;
        roll_cnt++   ;
        packet_cnt = packet_cnt & 0x1FFF ; // 0~8191
        roll_cnt   = roll_cnt   & 0x00FF ; // 0~255
    }
} ;

// Simple Timecode
struct Timecode {
        uint8_t h, m, s, f {0} ; 
} ;

// Packet Header
struct Header {
     union {
        uint8_t       __data[24]{0} ;
        struct {
            uint16_t   packet_count, centroid_count ;
            uint8_t    flag, dtype, roll_count, size, tc_h, tc_m, tc_s, tc_f ;
            uint16_t   frag_num, frag_count ;  
            uint32_t   img_os, img_sz ;
        } ;
     } ;
} ;

} // namespace CamConsts

namespace vision {
// Just borrowed from the computer vusion lib in the main branch - just for testing & experimentation

// 8-Byte Centroid format
struct packedCentroids8 {
uint16_t  xd ; // Decimal part of X
uint8_t   xf ; // Fractional part of X

uint16_t  yd ; // Decimal part of Y
uint8_t   yf ; // Fractional part of Y

uint8_t   rd ; // Decimal part of Radius
uint8_t   rf ; // Fractional part of Radius
} ;
typedef std::vector< packedCentroids8 > Roid8Vec_t ;

} // namespace vision